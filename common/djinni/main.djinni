user = record {
    login: string;
    id: i32;
    avatar_url: string;
    created_at: date;
}

repo = record {
    id: i32;
    name: string;
    full_name: string;
    owner: i32;
    priv: bool;
    descr: optional<string>;
    created_at: date;
}

get_user_cb = interface +j +c {
    on_success(user : user);
    on_error(error: string);
}

get_users_cb = interface +j +c {
    on_success(users : list<user>);
    on_error(error: string);
}

get_repos_cb = interface +j +c {
    on_success(repos : list<repo>, u: user);
    on_error(error: string);
}

platform_threads = interface +j +c {
    create_thread(name: string, func: thread_func);

    run_on_main_thread(func: thread_func);

    is_main_thread(): bool;
}

thread_func = interface +c {
    run();
}

xptuto = interface +c {
    static make_instance(client: http_client, threads: platform_threads) : xptuto;

    get_user(login: string, cb : get_user_cb);

    get_users(cb : get_users_cb);

    get_repos_for_user(usr: user, cb: get_repos_cb);
}

http_callback = interface +c {

    on_failure(reason: string);
    # in the generated C++ class, change this to string_view
    on_response(body: string, code: i32);

}

http_response = record {
    code: optional<i32>;
    body: optional<string>;
}

http_client = interface +j +c {
    get(url: string, callback: http_callback);

    get_sync(url: string): http_response;
}